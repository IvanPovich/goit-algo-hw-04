# goit-algo-hw-04
## Порівняння та висновки

- **Insertion Sort** значно програє іншим алгоритмам за швидкістю, особливо на великих наборах даних.
  
  Алгоритм сортування вставкою є досить повільним для великих масивів, оскільки має квадратичну часову складність у гіршому випадку \(O(n^2))\. Це робить його менш ефективним порівняно з іншими алгоритмами сортування.

- **Merge Sort** показує значно кращі результати, але все ж поступається вбудованій функції Python.
  
  Алгоритм сортування злиттям працює швидше завдяки логарифмічній часовій складності \(O(n log n))\, яка забезпечує стабільну ефективність навіть на великих наборах даних. Цей алгоритм, хоч і потребує додаткової пам'яті для виконання, показує дуже хороший результат.

- **Вбудована функція Python** є найшвидшою, оскільки вона оптимізована для різноманітних типів даних і реальних сценаріїв використання.
  
  Вбудована функція сортування Python (`sorted`) виявилася найшвидшою. Вона використовує Timsort, який є гібридом сортування вставками та сортування злиттям, що робить його дуже оптимізованим для реальних даних.

### Загальні висновки

Таким чином, для більшості практичних завдань варто використовувати вбудовану функцію Python або алгоритми з часовою складністю \(O(n log n))\, такі як Merge Sort. Insertion Sort можна розглядати для малих наборів даних або вже частково відсортованих масивів.
